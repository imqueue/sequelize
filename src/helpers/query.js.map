{"version":3,"file":"query.js","sourceRoot":"","sources":["query.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * @imqueue/sequelize - Sequelize ORM refines for @imqueue\n *\n * Copyright (c) 2019, imqueue.com <support@imqueue.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\nimport { js } from '@imqueue/js';\nimport { CountOptions, Includeable, Transaction } from 'sequelize';\nimport {\n    Association,\n    FindOptions,\n    IncludeOptions,\n    ModelAttributes,\n    Op,\n} from 'sequelize';\nimport { Model } from 'sequelize-typescript';\nimport { Literal } from 'sequelize/types/lib/utils';\nimport { database } from '..';\nimport { BaseModel, SaveOptions, Sequelize } from '../BaseModel';\nimport {\n    FieldsInput,\n    FILTER_OPS,\n    FilterInput,\n    OrderByInput,\n    OrderDirection,\n    PaginationInput,\n} from '../types';\n\nexport namespace query {\n    import isObject = js.isObject;\n    import isArray = js.isArray;\n\n    const RX_OP = /^\\$/;\n    const RX_LIKE = /%/;\n    const RX_LTE = /^<=/;\n    const RX_GTE = /^>=/;\n    const RX_LT = /^</;\n    const RX_GT = /^>/;\n    const RX_EQ = /^=/;\n    const RX_RANGE = /Range$/;\n    const RX_SPACE = /\\s/;\n    const RX_SQL_CLEAN = /\\s+(;|$)/;\n    const RX_SQL_END = /;?$/;\n\n    interface PureDataFunction {\n        <M extends Model<M>, T>(\n            model: typeof Model,\n            input: T,\n            attributes?: string[],\n        ): ModelAttributes;\n        <M extends Model<M>, T>(\n            model: typeof Model,\n            input: T[],\n            attributes?: string[],\n        ): ModelAttributes[];\n    }\n\n    /**\n     * Performs safe trimming space characters inside SQL query input string\n     * and inline it.\n     *\n     * @param {string} input - input string\n     * @return {string} - sanitized string\n     */\n    export function safeSqlSpaceCleanup(input: string): string {\n        let output = '';\n        let opened = false;\n        let space = false;\n\n        for (const char of input) {\n            if (!opened && RX_SPACE.test(char)) {\n                if (!space) {\n                    output += ' ';\n                }\n\n                space = true;\n            } else {\n                output += char;\n                space = false;\n            }\n\n            if (char === '\\'') {\n                opened = !opened;\n            }\n        }\n\n        return output;\n    }\n\n    // tslint:disable-next-line:max-line-length\n    // noinspection JSUnusedGlobalSymbols\n    /**\n     * SQL tag used to tag sql queries\n     *\n     * @param {string | TemplateStringsArray} sqlQuery\n     * @param {...any[]} [rest] - anything else\n     * @return {string}\n     */\n    export function sql(\n        sqlQuery: string | TemplateStringsArray,\n        ...rest: any[]\n    ): string {\n        return safeSqlSpaceCleanup(String(sqlQuery))\n            .replace(RX_SQL_CLEAN, '')\n            .replace(RX_SQL_END, ';');\n    }\n\n    /**\n     * Extracts pure data from given input data for a given model\n     *\n     * @param {typeof Model} model\n     * @param {any | any[]} input\n     * @param {string[]} [attributes]\n     * @return {M}\n     */\n    export const pureData: PureDataFunction = <T, M extends BaseModel<M>>(\n        model: typeof BaseModel,\n        input: T | T[],\n        attributes?: string[],\n    ) => {\n        attributes = attributes || Object.keys(model.rawAttributes || {});\n\n        if (isArray(input)) {\n            return (input as T[]).map(inputItem => pureData(\n                model,\n                inputItem,\n                attributes as string[],\n            ));\n        }\n\n        return Object.keys(input).reduce((res: any, prop: string) => {\n            if (~(attributes as string[]).indexOf(prop)) {\n                res[prop] = (input as any)[prop];\n            }\n\n            return res;\n        }, {});\n    };\n\n    // noinspection JSUnusedGlobalSymbols\n    /**\n     * Omits non-related properties from a given fields map object associated\n     * with the given model\n     *\n     * @param {typeof Model} model\n     * @param {any} fields\n     * @return {string[]}\n     */\n    export function pureFields(\n        model: typeof BaseModel,\n        fields: any,\n    ): string[] | true {\n        if (!fields) {\n            return true;\n        }\n\n        const attributes = Object.keys(model.rawAttributes || {});\n        const list = Object.keys(\n            Object.keys(fields).reduce((res: any, prop: string) => {\n                if (~attributes.indexOf(prop)) {\n                    res[prop] = fields[prop];\n                }\n\n                return res;\n            }, {}),\n        );\n\n        // make sure it contains primary key fields\n        // that's a tiny trade-off to make sure we won't loose it for a domain\n        // logic to use\n        primaryKeys(model).forEach(fieldName =>\n            !~list.indexOf(fieldName) && list.push(fieldName),\n        );\n\n        return list;\n    }\n\n    // noinspection JSUnusedGlobalSymbols\n    /**\n     * Returns true if given fields contains associations from given model,\n     * false otherwise\n     *\n     * @param {typeof Model} model\n     * @param {any} fields\n     * @return {boolean}\n     */\n    export function needNesting(model: typeof Model, fields: any): boolean {\n        if (!fields) {\n            return false;\n        }\n\n        const associations = Object.keys(model.associations || {});\n        const properties = Object.keys(fields);\n\n        if (!associations.length) {\n            return false;\n        }\n\n        return associations.some(name => !!~properties.indexOf(name));\n    }\n\n    /**\n     * Returns list of filtered attributes from model through a given list of\n     * user requested fields\n     *\n     * @param {any} attributes\n     * @param {string[]} fields\n     * @param {typeof BaseModel} [model]\n     * @return {string[]}\n     */\n    export function filtered(\n        attributes: any,\n        fields: string[],\n        model?: typeof BaseModel,\n    ): string[] {\n        let filteredAttributes =  (attributes\n            ? Object.keys(attributes).filter(attr => ~fields.indexOf(attr))\n            : []);\n\n        if (!filteredAttributes.length && model) {\n            filteredAttributes = primaryKeys(model);\n        }\n\n        return filteredAttributes;\n    }\n\n    /**\n     * Extracts foreign keys existing on the given model for a given list of\n     * associations and returns as field names list\n     *\n     * @param {typeof BaseModel} model\n     * @param {string[]} relations\n     * @return {string[]}\n     */\n    export function foreignKeys(\n        model: typeof BaseModel,\n        relations: string[],\n    ): string[] {\n        const associations: {\n            [name: string]: Association,\n        } = model.associations || {};\n\n        return relations.map((name: string) => {\n            const association = (associations[name] || {}) as any;\n\n            if (association.source === model &&\n                association.foreignKey && (!(\n                    association.sourceKey ||\n                    association.associationType === 'BelongsToMany'\n                ))\n            ) {\n                return association.foreignKey;\n            }\n\n            return null;\n        })\n        .filter(idField => idField) || [];\n    }\n\n    /**\n     * Merges given arrays of scalars making sure they contains unique values\n     *\n     * @param {any[][]} args\n     * @return {any[]}\n     */\n    function arrayMergeUnique(...args: any[][]): any[] {\n        const result: any[] = [];\n\n        for (const arr of args) {\n            result.push(...arr);\n        }\n\n        return result.filter((item, index) => result.indexOf(item) === index);\n    }\n\n    /**\n     * Makes sure all merge arguments are merged into a given query\n     *\n     * @param {any} [queryOptions]\n     * @param {...any[]} merge\n     * @return - merged query options\n     */\n    export function mergeQuery(queryOptions: any = {}, ...merge: any[]): any {\n        for (const item of merge) {\n            if (!item) {\n                continue;\n            }\n\n            for (const prop of Object.keys(item)) {\n                const err = `Given ${prop} option is invalid!`;\n\n                if (typeof queryOptions[prop] === 'undefined') {\n                    queryOptions[prop] = item[prop];\n                    continue;\n                }\n\n                if (typeof item[prop] === 'undefined') {\n                    continue;\n                }\n\n                if (isArray(queryOptions[prop])) {\n                    if (!isArray(item[prop])) {\n                        throw new TypeError(err);\n                    }\n\n                    for (const element of item[prop]) {\n                        if (!~queryOptions[prop].indexOf(element)) {\n                            queryOptions[prop].push(element);\n                        }\n                    }\n                    continue;\n                }\n\n                if (isObject(queryOptions[prop])) {\n                    if (!isObject(item[prop])) {\n                        throw new TypeError(err);\n                    }\n\n                    Object.assign(queryOptions[prop], item[prop]);\n                    continue;\n                }\n\n                queryOptions[prop] = item[prop];\n            }\n        }\n\n        return queryOptions;\n    }\n\n    /**\n     * Automatically map query joins and requested attributes from a given\n     * fields map to a given model and returns query find options. Additionally\n     * will merge all given options as the rest arguments.\n     *\n     * @param {Model} model - model to build query for\n     * @param {any} fields - map of the fields requested by a user or a list\n     *                       of fields for a root object (without associations)\n     * @param {...Array<Partial<T> | undefined>} merge - other query parts to\n     *                                                   merge with\n     * @return {T} - query options type specified by a call\n     */\n    export function autoQuery<T>(\n        model: any,\n        fields?: any,\n        ...merge: Array<Partial<T> | undefined>\n    ): T {\n        const queryOptions: any = {};\n        const { order } = merge.find((item: any) => item && !!item.order) ||\n            {} as any;\n\n        if (order && isArray(order)) {\n            // make sure order arg will not break selection\n            for (const [field] of order) {\n                if (fields && typeof fields[field] === 'undefined') {\n                    fields[field] = false;\n                }\n            }\n        }\n\n        if (isArray(fields)) {\n            queryOptions.attributes = filtered(\n                model.rawAttributes, fields, model,\n            );\n        } else if (fields) {\n            const fieldNames = Object.keys(fields);\n            // relations which are requested by a user\n            const relations = filtered(model.associations, fieldNames);\n            // attributes which are requested by a user\n            queryOptions.attributes = arrayMergeUnique(\n                filtered(model.rawAttributes, fieldNames, model),\n                foreignKeys(model, relations),\n            );\n\n            // we may want to check if the given field is being filtered\n            // and build where clause for it\n            Object.assign(queryOptions, toWhereOptions(\n                queryOptions.attributes.reduce((res: any, attr: string) => {\n                    if (fields[attr] !== false) {\n                        res[attr] = fields[attr];\n                    }\n\n                    return res;\n                }, {}),\n            ));\n\n            if (relations.length) {\n                queryOptions.include = [];\n\n                for (const rel of relations) {\n                    const relModel = model.associations[rel].target;\n\n                    // noinspection TypeScriptUnresolvedVariable\n                    queryOptions.include.push({\n                        model: relModel,\n                        as: model.associations[rel].options.as,\n                        ...autoQuery<any>(relModel, fields[rel]),\n                    } as any);\n                }\n            }\n        }\n\n        if (merge.length) {\n            mergeQuery(queryOptions, ...merge);\n        }\n\n        return queryOptions as T;\n    }\n\n    /**\n     * Return names of primary key fields for a given model.\n     *\n     * @param {typeof BaseModel} model\n     * @return {string[]}\n     */\n    export function primaryKeys(model: typeof BaseModel): string[] {\n        const fields = model.rawAttributes;\n\n        return Object.keys(fields).filter(name => fields[name].primaryKey);\n    }\n\n    /**\n     * Related entity arguments type used to be passed to createEntity()\n     * subsequent calls.\n     *\n     * @type {RelationArgs}\n     * @access private\n     */\n    type RelationArgs = Array<[\n        any,\n        any,\n        FieldsInput | undefined,\n        Transaction | undefined,\n        string\n    ]>;\n\n    /**\n     * Foreign key map representation, where related property name references\n     * parent property name.\n     *\n     * @type {ForeignKeyMap}\n     * @access private\n     */\n    interface ForeignKeyMap {\n        [property: string]: string;\n    }\n\n    /**\n     * Returns foreign key map for a given pair of parent model and related\n     * model.\n     *\n     * @param {typeof BaseModel} parent\n     * @param {typeof BaseModel} model\n     * @return {ForeignKeyMap}\n     * @access private\n     */\n    export function foreignKeysMap(\n        parent: typeof BaseModel,\n        model: typeof BaseModel,\n    ): ForeignKeyMap | null {\n        let found = false;\n\n        const map: ForeignKeyMap = Object.keys(model.rawAttributes)\n            .reduce((fkMap, name) => {\n                const relation = model.rawAttributes[name].references;\n\n                if (relation &&\n                    relation.model === parent.name && relation.key\n                ) {\n                    fkMap[name] = relation.key;\n                    found = true;\n                }\n\n                return fkMap;\n            }, {} as ForeignKeyMap);\n\n        return found ? map : null;\n    }\n\n    /**\n     * Prepares input for a given model and builds found relation arguments\n     *\n     * @access private\n     * @param {any} input\n     * @param {string[]} relations\n     * @param {typeof BaseModel} model\n     * @param {FieldsInput} [fields]\n     * @param {Transaction} [transaction]\n     * @param {T} [parent]\n     * @return {RelationArgs}\n     */\n    function prepareInput<T extends BaseModel<T>>(\n        input: any,\n        relations: string[],\n        model: typeof BaseModel,\n        fields?: FieldsInput,\n        transaction?: Transaction,\n        parent?: T,\n    ): RelationArgs {\n        const args: RelationArgs = [];\n\n        for (const relation of relations) {\n            args.push([\n                model.associations[relation].target,\n                input[relation],\n                fields ? fields[relation] as FieldsInput : undefined,\n                transaction,\n                relation,\n            ]);\n\n            delete input[relation];\n        }\n\n        if (parent) {\n            const foreignKey = foreignKeysMap(\n                parent.constructor as typeof BaseModel,\n                model,\n            );\n\n            foreignKey && Object.keys(foreignKey).forEach(property => {\n                if (!(input as any)[property]) {\n                    (input as any)[property] = (parent as any)[\n                        foreignKey[property]\n                    ];\n                }\n            });\n        }\n\n        return args;\n    }\n\n    // noinspection JSUnusedGlobalSymbols\n    /**\n     * Recursively creates entity and all it's relations from a given input\n     * using a given model.\n     *\n     * @param {T} model - model class to map entity to\n     * @param {I} input - data input object related to a given model\n     * @param {FieldsInput} [fields] - fields map to return on created entity\n     * @return {Promise<Partial<T>>}\n     */\n    export async function createEntity<T extends BaseModel<T>, I>(\n        model: typeof BaseModel,\n        input: I,\n        fields?: FieldsInput,\n    ): Promise<Partial<T>> {\n        return await doCreateEntity(model, input, fields);\n    }\n\n    /**\n     * Recursively creates entity and all it's relations from a given input\n     * using a given model.\n     *\n     * @param {T} model\n     * @param {I | I[]} input\n     * @param {FieldsInput} [fields]\n     * @param {Transaction} [transaction]\n     * @param {string} [parentProperty]\n     * @param {boolean} [noAppend]\n     * @param {T} parent\n     * @return {Promise<Partial<T>>}\n     * @access private\n     */\n    async function doCreateEntity<T extends BaseModel<T>, I>(\n        model: typeof BaseModel,\n        input: I | I[],\n        fields?: FieldsInput,\n        transaction?: Transaction,\n        parentProperty?: string,\n        parent?: T,\n        noAppend: boolean = false,\n    ): Promise<Partial<T>> {\n        transaction = transaction || await database().transaction({\n            autocommit: false,\n        });\n\n        // todo: this could be optimized through bulk operations\n        if (isArray(input) && parentProperty && parent) {\n            parent.appendChild(\n                parentProperty,\n                await Promise.all((input as I[]).map(inputItem =>\n                    doCreateEntity(\n                        model, inputItem, fields, transaction,\n                        parentProperty, parent, true,\n                    )),\n                ),\n            );\n\n            return parent;\n        }\n\n        if (fields) {\n            primaryKeys(model).forEach(name =>\n                !fields[name] && (fields[name] = false));\n        }\n\n        const fieldNames = Object.keys(input);\n        const relationArgs = prepareInput<T>(\n            input, filtered(model.associations, fieldNames),\n            model, fields, transaction, parent);\n        const entity = new (model as any)(input as any as ModelAttributes);\n\n        await entity.save({\n            transaction,\n            returning: fields\n                ? filtered(model.rawAttributes, Object.keys(fields), model)\n                : true,\n        } as SaveOptions);\n\n        if (!noAppend && parentProperty && parent) {\n            parent.appendChild(parentProperty, entity);\n        }\n\n        await Promise.all(relationArgs.map(async args => {\n            args.push(entity);\n            await doCreateEntity(...args);\n        }));\n\n        if (!parent) {\n            await transaction.commit();\n        }\n\n        return entity;\n    }\n\n    // noinspection JSUnusedGlobalSymbols\n    /**\n     * Builds and returns count query for a given query options and model.\n     *\n     * @param {Model} model\n     * @param {any} fields\n     * @param {Array<Partial<CountOptions> | undefined>} merge\n     * @return {CountOptions}\n     */\n    export function autoCountQuery(\n        model: any,\n        fields?: any,\n        ...merge: Array<Partial<CountOptions> | undefined>\n    ): CountOptions {\n        const queryOptions = autoQuery<CountOptions>(model, fields, ...merge);\n\n        if (queryOptions.attributes) {\n            delete queryOptions.attributes;\n        }\n\n        return queryOptions;\n    }\n\n    // noinspection JSUnusedGlobalSymbols\n    /**\n     * Builds proper paging options query part\n     *\n     * @param {PaginationInput} [pageOptions] - obtained pagination input\n     *                                          from remote\n     * @return {FindOptions} - pagination part of the query\n     */\n    export function toLimitOptions<T>(\n        pageOptions?: PaginationInput,\n    ): FindOptions {\n        const page: FindOptions = {};\n\n        if (!pageOptions || !+pageOptions.limit) {\n            return page;\n        }\n\n        page.offset = 0;\n        page.limit = 0;\n\n        const count = pageOptions.count || 0;\n\n        if (pageOptions.offset) {\n            page.offset = pageOptions.offset;\n        }\n\n        if (pageOptions.limit) {\n            page.limit = Math.abs(pageOptions.limit);\n        }\n\n        if (pageOptions.limit < 0) {\n            if (page.offset === 0) {\n                page.offset = count - page.limit;\n            }\n\n            if (page.offset < 0) {\n                page.offset = 0;\n            }\n        }\n\n        return page;\n    }\n\n    /**\n     * Ensures order by value is correct or returns default (ASC) if not. This\n     * would prevent from any possible injections or errors.\n     *\n     * @param {any} value\n     * @return {OrderDirection}\n     */\n    function toOrderDirection(value: any): OrderDirection {\n        if (String(value).toLocaleLowerCase() === 'desc') {\n            return OrderDirection.desc;\n        } else {\n            return OrderDirection.asc;\n        }\n    }\n\n    // noinspection JSUnusedGlobalSymbols\n    /**\n     * Constructs order by part of the query from a given input orderBy object\n     *\n     * @param {any} orderBy\n     */\n    export function toOrderOptions<T>(\n        orderBy?: OrderByInput,\n    ): FindOptions {\n        const order: FindOptions = {};\n\n        if (!orderBy) {\n            return order;\n        }\n\n        const fields: string[] = Object.keys(orderBy);\n\n        if (!fields.length) {\n            return order;\n        }\n\n        order.order = [];\n\n        for (const field of fields) {\n            (order.order as Array<[string, string]>).push(\n                [field, toOrderDirection(orderBy[field])],\n            );\n        }\n\n        return order;\n    }\n\n    // noinspection JSUnusedGlobalSymbols\n    /**\n     * Adds or null check to a given where field values\n     *\n     * @param {string | string[]} value\n     * @return {FindOptions}\n     */\n    export function orNull(value: string | string[]): Partial<FindOptions> {\n        if (isArray(value)) {\n            return { [Op.or]: [null, ...value] } as FindOptions;\n        }\n\n        return { [Op.or]: [null, value] } as FindOptions;\n    }\n\n    /**\n     * Rich filters implementation. Actually by doing this we allow outside\n     * calls to replicate what sequelize does for us: building rich where\n     * clauses.\n     *\n     * @param {FilterInput} filter\n     * @return {FindOptions}\n     */\n    function parseFilter<T>(filter: FilterInput): FindOptions {\n        const clause: FindOptions = {};\n\n        if (Object.prototype.toString.call(filter) === '[object Object]') {\n            for (const op of Object.keys(filter)) {\n                if ((FILTER_OPS as any)[op]) {\n                    (clause as any)[(FILTER_OPS as any)[op]] = parseFilter(\n                        (filter as any)[op],\n                    );\n                } else {\n                    (clause as any)[op] = parseFilter((filter as any)[op]);\n                }\n            }\n        } else {\n            // that's recursive value reached\n            return filter as any;\n        }\n\n        return clause;\n    }\n\n    /**\n     * This gives us an ability to simulate ILIKE, <, >, <=, >=, = right withing\n     * given values in the filter.\n     *\n     * @param {string} prop\n     * @param {any} data\n     * @return {IFindOptions<T>>}\n     */\n    function parseFilterValue<T>(prop: string, data: any): FindOptions {\n        const value: any = { [prop]: data };\n\n        if (typeof data !== 'string') {\n            return value;\n        }\n\n        if (RX_LIKE.test(data)) {\n            value[prop] = { [Op.iLike]: data };\n        } else if (RX_GTE.test(data)) {\n            value[prop] = { [Op.gte]: parseValue(data.replace(RX_GTE, '')) };\n        } else if (RX_GT.test(data)) {\n            value[prop] = { [Op.gt]: parseValue(data.replace(RX_GT, '')) };\n        } else if (RX_LTE.test(data)) {\n            value[prop] = { [Op.lte]: parseValue(data.replace(RX_LTE, '')) };\n        } else if (RX_LT.test(data)) {\n            value[prop] = { [Op.lt]: parseValue(data.replace(RX_LT, '')) };\n        } else if (RX_EQ.test(data)) {\n            value[prop] = { [Op.eq]: parseValue(data.replace(RX_EQ, '')) };\n        }\n\n        return value as FindOptions;\n    }\n\n    /**\n     * Parses a given value\n     * @param value\n     */\n    function parseValue(value: string) {\n        try {\n            const date = new Date(value);\n            if (date.toISOString() === value) {\n                return date;\n            }\n        } catch (err) { /* not a date */ }\n\n        return ((+value + '') === value) ? +value : value;\n    }\n\n    /**\n     * Builds toWhereOptions clause query sub-part for a given filter type\n     *\n     * @param {T} filter\n     * @return {any} - toWhereOptions clause options\n     */\n    export function toWhereOptions<T>(filter?: T): any {\n        if (!filter) {\n            return {};\n        }\n\n        const options: any = {};\n\n        for (const prop of Object.keys(filter)) {\n            let data: any = (filter as any)[prop];\n\n            if (isArray(data)) {\n                if (data.length === 0) {\n                    continue;\n                }\n\n                if (data.length === 1) {\n                    data = data[0];\n                }\n            }\n\n            if (data === undefined) {\n                continue;\n            }\n\n            options.where = options.where || {};\n\n            if (RX_OP.test(prop)) {\n                Object.assign(\n                    options.where,\n                    parseFilter({ [prop]: data, } as FilterInput),\n                );\n            } else if (data && data.start && data.end) { // range filter\n                Object.assign(options.where, {\n                    [prop]: { [Op.between]: [data.start, data.end] },\n                });\n            } else if (\n                Object.prototype.toString.call(data) === '[object Object]'\n            ) {\n                Object.assign(options.where, { [prop]: parseFilter(data) });\n            } else if (isArray(data)) {\n                Object.assign(options.where, { [prop]: { [Op.in]: data } });\n            } else {\n                Object.assign(options.where, parseFilterValue(prop, data));\n            }\n        }\n\n        return options;\n    }\n\n    // noinspection JSUnusedGlobalSymbols\n    /**\n     * Will apply a range rule on a given filters. The rule is simple. If\n     * filter query contains fields named as [ColumnName]IRange it will try to\n     * convert those fields to a proper range filter if the value is a proper\n     * RangeFilter interface as { start: something, end: something }\n     * If nothing is matched will simply ignores and keep filtering props\n     * as them are.\n     *\n     * @param {any} filter\n     * @return {any}\n     */\n    export function withRangeFilters(filter: any) {\n        if (!filter) {\n            return filter;\n        }\n\n        for (const prop of Object.keys(filter)) {\n            const col = prop.replace(RX_RANGE, '');\n\n            if (col === prop) { // not a range filter\n                if (isObject(filter[prop])) {\n                    withRangeFilters(filter[prop]);\n                }\n\n                continue;\n            }\n\n            const signature = Object.keys(filter[prop]) + '';\n\n            if (!~['start,end', 'end,start'].indexOf(signature)) {\n                continue; // not a range filter signature\n            }\n\n            if (filter[col]) {\n                throw new TypeError(\n                    `Only one of filtering options \"${col\n                    }\" or \"${prop}\" can be passed as filtering option!`,\n                );\n            }\n\n            filter[col] = filter[prop];\n            delete filter[prop];\n        }\n\n        return filter;\n    }\n\n    // noinspection JSUnusedGlobalSymbols\n    /**\n     * Looks up and returns include options in a given query using an array of\n     * given models as a search path\n     *\n     * @param {FindOptions} queryOptions\n     * @param {Array<typeof Model>} path\n     * @return {IncludeOptions | null}\n     */\n    export function getInclude(\n        queryOptions: FindOptions,\n        path: Array<typeof Model>,\n    ): IncludeOptions | null {\n        const currentModel = path.shift();\n\n        for (const include of (queryOptions.include || [])) {\n            const model = (include as IncludeOptions).model;\n\n            // noinspection TypeScriptValidateTypes\n            if (model === currentModel) {\n                if (!path.length) {\n                    return include as IncludeOptions;\n                } else {\n                    return getInclude(include as FindOptions, path);\n                }\n            }\n        }\n\n        return null;\n    }\n\n    // noinspection JSUnusedLocalSymbols,JSCommentMatchesSignature\n    /**\n     * Returns sequelize Literal build from a given string or string template\n     * Actually it's an alias for Sequelize.Literal\n     *\n     * @example\n     * ```typescript\n     * const owner = 3;\n     * const query = {\n     *   where: L`(SELECT COUNT(*) FROM \"SomeTable\" WHERE owner = ${E(id)}) = 0`\n     * }\n     * ```\n     * @param {TemplateStringsArray | string} str\n     * @return {Literal}\n     */\n    export function L(\n        str: TemplateStringsArray | string,\n        ..._: any[]\n    ): Literal {\n        return Sequelize.literal(str as string);\n    }\n\n    /**\n     * Escapes given argument. If argument is not a number or a string will\n     * convert it to 'NULL'\n     *\n     * @param {any} input\n     * @return {string | number}\n     */\n    export function E(input: any) {\n        if (typeof input === 'number') {\n            return +input;\n        }\n\n        if (typeof input === 'string') {\n            return `'${input}'`;\n        }\n\n        return 'NULL';\n    }\n\n    // noinspection JSUnusedGlobalSymbols\n    /**\n     * Removes given properties from the given object\n     *\n     * @param {any} obj\n     * @param {...string[]} props\n     * @return {any}\n     */\n    export function skip(obj: any, ...props: string[]) {\n        if (!obj) {\n            return obj;\n        }\n\n        for (const prop of props) {\n            delete obj[prop];\n        }\n\n        return obj;\n    }\n\n    // noinspection JSUnusedGlobalSymbols\n    /**\n     * Traverses given query object, lookups for includes matching\n     * the given arguments of include options and overrides those are matching\n     * by model and alias with the provided option.\n     *\n     * @param {FindOptions | CountOptions} queryOptions\n     * @param {...IncludeOptions[]} options\n     * @return {FindOptions | CountOptions}\n     */\n    export function overrideJoin(\n        queryOptions: FindOptions | CountOptions,\n        ...options: IncludeOptions[]\n    ): FindOptions | CountOptions {\n        if (!(queryOptions && queryOptions.include) || !options.length) {\n            return queryOptions;\n        }\n\n        for (const { model, ...fields } of options) {\n            let found = false;\n\n            for (const include of queryOptions.include as IncludeOptions[]) {\n                const as = fields.as;\n\n                if (include as any === model || (\n                    include.model === model && (!as || as === include.as)\n                )) {\n                    Object.assign(include, fields);\n                    found = true;\n                }\n            }\n\n            if (!found) {\n                queryOptions.include.push({ model, ...fields } as Includeable);\n            }\n        }\n\n        return queryOptions;\n    }\n}\n"]}