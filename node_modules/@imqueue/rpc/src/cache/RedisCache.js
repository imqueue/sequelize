"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@imqueue/core");
const os = require("os");
exports.DEFAULT_REDIS_CACHE_OPTIONS = Object.assign({}, core_1.DEFAULT_IMQ_OPTIONS, { prefix: 'imq-cache' });
/**
 * Class RedisCache. Implements cache engine over redis.
 */
class RedisCache {
    constructor() {
        this.name = RedisCache.name;
        this.ready = false;
    }
    /**
     * Initializes cache instance
     *
     * @param {IRedisCacheOptions} [options]
     * @returns {Promise<RedisCache>}
     */
    async init(options) {
        this.options = Object.assign({}, exports.DEFAULT_REDIS_CACHE_OPTIONS, options);
        this.logger = this.options.logger ||
            // istanbul ignore next
            console;
        if (RedisCache.redis) {
            return this;
        }
        if (this.options.conn) {
            this.logger.info('Re-using given connection for cache.');
            RedisCache.redis = this.options.conn;
            return this;
        }
        return new Promise((resolve, reject) => {
            RedisCache.redis = core_1.redis.createClient(Number(this.options.port), String(this.options.host));
            RedisCache.redis.on('ready', async () => {
                this.logger.info('%s: redis cache connected, host %s:%s, pid %s', this.name, this.options.host, this.options.port, process.pid);
                await RedisCache.redis.client('setname', `${this.options.prefix}:${this.name}:pid:${process.pid}:host:${os.hostname()}`);
                this.ready = true;
                resolve(this);
            });
            // istanbul ignore next
            RedisCache.redis.on('error', (err) => {
                this.logger.error(`${this.name}: error connecting redis, pid ${process.pid}:`, err);
                reject(err);
            });
        });
    }
    /**
     * Returns fully qualified key name for a given generic key
     *
     * @access private
     * @param {string} key
     * @returns {string}
     */
    key(key) {
        return `${this.options.prefix}:${this.name}:${key}`;
    }
    /**
     * Returns value stored in cache by a given key
     *
     * @param {string} key
     * @returns {Promise<any>}
     */
    async get(key) {
        const data = await RedisCache.redis.get(this.key(key));
        if (data) {
            return JSON.parse(data);
        }
        return undefined;
    }
    /**
     * Stores in cache given value under given key. If TTL is specified,
     * cached value will expire in a given number of milliseconds. If NX
     * argument set to true will create key:value in cache only if it does
     * not exists yet. Given value could be any JSON-compatible object and
     * will be serialized automatically.
     *
     * @param {string} key
     * @param {any} value
     * @param {number} ttl
     * @param {boolean} nx
     * @returns {Promise<boolean>}
     */
    async set(key, value, ttl, nx = false) {
        const args = [
            this.key(key),
            JSON.stringify(value && value.then ? await value : value)
        ];
        if (ttl && ttl > 0) {
            args.push('PX', ttl);
        }
        if (nx) {
            args.push('NX');
        }
        return await RedisCache.redis.set.apply(RedisCache.redis, args);
    }
    /**
     * Removes stored in cache value under given key
     *
     * @param {string} key
     * @returns {Promise<boolean>}
     */
    async del(key) {
        return await RedisCache.redis.del(this.key(key));
    }
    /**
     * Safely destroys redis connection
     *
     * @returns {Promise<void>}
     */
    static async destroy() {
        try {
            // istanbul ignore else
            if (RedisCache.redis) {
                RedisCache.redis.removeAllListeners();
                RedisCache.redis.end(false);
                RedisCache.redis.unref();
                delete RedisCache.redis;
            }
        }
        catch (err) { }
    }
}
exports.RedisCache = RedisCache;
//# sourceMappingURL=RedisCache.js.map