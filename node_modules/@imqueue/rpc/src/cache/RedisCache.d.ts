/*!
 * RedisCache adapter implementation
 *
 * Copyright (c) 2018, imqueue.com <support@imqueue.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
import { ICache } from '.';
import { ILogger, IRedisClient, IMQOptions } from '@imqueue/core';
export interface IRedisCacheOptions extends Partial<IMQOptions> {
    conn?: IRedisClient;
}
export declare const DEFAULT_REDIS_CACHE_OPTIONS: {
    prefix: string;
    cleanup: boolean;
    cleanupFilter: string;
    host?: string | undefined;
    port?: number | undefined;
    vendor?: string | undefined;
    logger?: ILogger | undefined;
    watcherCheckDelay?: number | undefined;
    useGzip?: boolean | undefined;
    safeDelivery?: boolean | undefined;
    safeDeliveryTtl?: number | undefined;
    cluster?: {
        host: string;
        port: number;
    }[] | undefined;
};
/**
 * Class RedisCache. Implements cache engine over redis.
 */
export declare class RedisCache implements ICache {
    private static redis;
    private logger;
    options: IRedisCacheOptions;
    name: string;
    ready: boolean;
    /**
     * Initializes cache instance
     *
     * @param {IRedisCacheOptions} [options]
     * @returns {Promise<RedisCache>}
     */
    init(options?: IRedisCacheOptions): Promise<RedisCache>;
    /**
     * Returns fully qualified key name for a given generic key
     *
     * @access private
     * @param {string} key
     * @returns {string}
     */
    private key;
    /**
     * Returns value stored in cache by a given key
     *
     * @param {string} key
     * @returns {Promise<any>}
     */
    get(key: string): Promise<any>;
    /**
     * Stores in cache given value under given key. If TTL is specified,
     * cached value will expire in a given number of milliseconds. If NX
     * argument set to true will create key:value in cache only if it does
     * not exists yet. Given value could be any JSON-compatible object and
     * will be serialized automatically.
     *
     * @param {string} key
     * @param {any} value
     * @param {number} ttl
     * @param {boolean} nx
     * @returns {Promise<boolean>}
     */
    set(key: string, value: any, ttl?: number, nx?: boolean): Promise<boolean>;
    /**
     * Removes stored in cache value under given key
     *
     * @param {string} key
     * @returns {Promise<boolean>}
     */
    del(key: string): Promise<boolean>;
    /**
     * Safely destroys redis connection
     *
     * @returns {Promise<void>}
     */
    static destroy(): Promise<void>;
}
