"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/*!
 * IMQClient implementation
 *
 * Copyright (c) 2018, imqueue.com <support@imqueue.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
const core_1 = require("@imqueue/core");
const _1 = require(".");
const ts = require("typescript");
const events_1 = require("events");
const vm = require("vm");
process.setMaxListeners(10000);
const tsOptions = require('../tsconfig.json').compilerOptions;
const SIGNALS = ['SIGTERM', 'SIGINT', 'SIGHUP', 'SIGBREAK'];
const RX_SEMICOLON = /;+$/g;
/**
 * Class IMQClient - base abstract class for service clients.
 */
class IMQClient extends events_1.EventEmitter {
    // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected
    /**
     * Class constructor
     *
     * @constructor
     * @param {Partial<IMQOptions>} options
     * @param {string} serviceName
     * @param {string} name
     */
    constructor(options, serviceName, name) {
        super();
        this.resolvers = {};
        const baseName = name || this.constructor.name;
        this.baseName = baseName;
        if (this.constructor.name === 'IMQClient') {
            throw new TypeError('IMQClient class is abstract and cannot ' +
                'be instantiated directly!');
        }
        this.options = Object.assign({}, _1.DEFAULT_IMQ_CLIENT_OPTIONS, options);
        this.id = _1.pid(baseName);
        this.logger = this.options.logger || /* istanbul ignore next */ console;
        this.name = `${baseName}-${_1.osUuid()}-${this.id}:client`;
        this.serviceName = serviceName || baseName.replace(/Client$/, '');
        this.imq = core_1.default.create(this.name, this.options);
        const terminate = async () => {
            await this.destroy();
            // istanbul ignore next
            process.nextTick(() => process.exit(0));
        };
        SIGNALS.forEach((signal) => process.on(signal, terminate));
        process.on('exit', terminate);
    }
    /**
     * Sends call to remote service method
     *
     * @access protected
     * @param {...any[]} args
     * @returns {Promise<T>}
     */
    async remoteCall(...args) {
        const method = args.pop();
        const from = this.name;
        const to = this.serviceName;
        let delay = 0;
        if (args[args.length - 1] instanceof _1.IMQDelay) {
            delay = args.pop().ms;
            // istanbul ignore if
            if (!isFinite(delay) || isNaN(delay) || delay < 0) {
                delay = 0;
            }
        }
        return new Promise(async (resolve, reject) => {
            try {
                const message = {
                    from,
                    method,
                    args,
                };
                const id = await this.imq.send(to, message, delay, reject);
                this.resolvers[id] = [resolve, reject];
            }
            catch (err) {
                // istanbul ignore next
                reject(err);
            }
        });
    }
    /**
     * Initializes client work
     *
     * @returns {Promise<void>}
     */
    async start() {
        this.imq.on('message', (message) => {
            // the following condition below is hard to test with the
            // current redis mock, BTW it was tested manually on real
            // redis run
            // istanbul ignore if
            if (!this.resolvers[message.to]) {
                // when there is no resolvers it means
                // we have massage in queue which was initiated
                // by some process which is broken. So we provide an
                // ability to handle enqueued messages via EventEmitter
                // interface
                this.emit(message.request.method, message);
            }
            const [resolve, reject] = this.resolvers[message.to];
            // make sure no memory leaking
            delete this.resolvers[message.to];
            if (message.error) {
                return reject && reject(message.error);
            }
            resolve && resolve(message.data);
        });
        await this.imq.start();
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * Stops client work
     *
     * @returns {Promise<void>}
     */
    async stop() {
        await this.imq.stop();
    }
    /**
     * Destroys client
     *
     * @returns {Promise<void>}
     */
    async destroy() {
        _1.forgetPid(this.baseName, this.id, this.logger);
        this.removeAllListeners();
        await this.imq.destroy();
    }
    /**
     * Returns service description metadata.
     *
     * @param {IMQDelay} delay
     * @returns {Promise<Description>}
     */
    async describe(delay) {
        return await this.remoteCall(...arguments);
    }
    /**
     * Creates client for a service with the given name
     *
     * @param {string} name
     * @param {Partial<IMQServiceOptions>} options
     * @returns {IMQClient}
     */
    static async create(name, options) {
        const clientOptions = Object.assign({}, _1.DEFAULT_IMQ_CLIENT_OPTIONS, options);
        return await generator(name, clientOptions);
    }
}
__decorate([
    _1.remote(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [_1.IMQDelay]),
    __metadata("design:returntype", Promise)
], IMQClient.prototype, "describe", null);
exports.IMQClient = IMQClient;
/**
 * Class GeneratorClient - generator helper class implementation
 * @access private
 */
class GeneratorClient extends IMQClient {
}
/**
 * Fetches and returns service description using the timeout (to handle
 * situations when the service is not started)
 *
 * @access private
 * @param {string} name
 * @param {IMQClientOptions} options
 * @returns {Promise<Description>}
 */
async function getDescription(name, options) {
    return new Promise(async (resolve, reject) => {
        const client = new GeneratorClient(options, name, `${name}Client`);
        await client.start();
        const timeout = setTimeout(async () => {
            await client.destroy();
            timeout && clearTimeout(timeout);
            reject(new EvalError('Generate client error: service remote ' +
                `call timed-out! Is service "${name}" running?`));
        }, options.timeout);
        const description = await client.describe();
        timeout && clearTimeout(timeout);
        await client.destroy();
        resolve(description);
    });
}
// codebeat:disable[LOC,ABC]
/**
 * Client generator helper function
 *
 * @access private
 * @param {string} name
 * @param {IMQClientOptions} options
 * @returns {Promise<string>}
 */
async function generator(name, options) {
    const description = await getDescription(name, options);
    const serviceName = description.service.name;
    const clientName = serviceName.replace(/Service$|$/, 'Client');
    const namespaceName = serviceName.charAt(0).toLowerCase() +
        serviceName.substr(1);
    let src = `/*!
 * IMQ-RPC Service Client: ${description.service.name}
 *
 * Copyright (c) ${new Date().getFullYear()}, imqueue.com <support@imqueue.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
import { IMQClient, IMQDelay, remote, profile } from '@imqueue/rpc';

export namespace ${namespaceName} {\n`;
    for (let typeName of Object.keys(description.types)) {
        src += `    export interface ${typeName} ${description.types[typeName].inherits &&
            description.types[description.types[typeName].inherits]
            ? `extends ${description.types[typeName].inherits}`
            : ''} {\n`;
        const indexType = description.types[typeName].indexType;
        if (indexType) {
            src += ' '.repeat(8);
            src += `${indexType.trim().replace(RX_SEMICOLON, '').trim()};\n`;
        }
        for (const propertyName of Object.keys(description.types[typeName].properties)) {
            const { type, isOptional } = description.types[typeName].properties[propertyName];
            src += ' '.repeat(8);
            src += `${propertyName}${isOptional ? '?' : ''}: ${type};\n`;
        }
        src += '    }\n\n';
    }
    src += `    export class ${clientName} extends IMQClient {\n\n`;
    const methods = description.service.methods;
    for (const methodName of Object.keys(methods)) {
        if (methodName === 'describe') {
            continue; // do not create inherited method - no need
        }
        const args = methods[methodName].arguments;
        const description = methods[methodName].description;
        const ret = methods[methodName].returns;
        let retType = ret.tsType
            .replace(/\r?\n/g, ' ')
            .replace(/\s{2,}/g, ' ');
        // make sure each method allows optional delay argument
        const lastArg = args[args.length - 1];
        if (lastArg && lastArg.type !== 'IMQDelay') {
            args.push({
                description: 'if passed the method will be called with ' +
                    'the specified delay over message queue',
                name: 'delay',
                type: 'IMQDelay',
                tsType: 'IMQDelay',
                isOptional: true
            });
        }
        // istanbul ignore if
        if (retType === 'Promise') {
            retType = 'Promise<any>';
        }
        src += '        /**\n';
        // istanbul ignore next
        src += description ? description.split(/\r?\n/)
            .map(line => `         * ${line}`)
            .join('\n') + '\n         *\n' : '';
        for (let i = 0, s = args.length; i < s; i++) {
            const arg = args[i];
            src += `         * @param {${toComment(arg.tsType)}} `;
            src += arg.isOptional ? `[${arg.name}]` : arg.name;
            src += arg.description ? ' - ' + arg.description : '';
            src += '\n';
        }
        src += `         * @return {${toComment(ret.tsType, true)}}\n`;
        src += '         */\n';
        src += '        @profile()\n';
        src += '        @remote()\n';
        src += `        public async ${methodName}(`;
        for (let i = 0, s = args.length; i < s; i++) {
            const arg = args[i];
            src += arg.name + (arg.isOptional ? '?' : '') +
                ': ' + arg.tsType.replace(/\s{2,}/g, ' ') +
                (i === s - 1 ? '' : ', ');
        }
        src += `): ${promisedType(retType)} {\n`;
        src += ' '.repeat(12);
        src += `return await this.remoteCall<${cleanType(retType)}>(...arguments);`;
        src += '\n        }\n\n';
    }
    src += '    }\n}\n';
    const module = await compile(name, src, options);
    return module ? module[namespaceName] : /* istanbul ignore next */ null;
}
// codebeat:enable[LOC,ABC]
/**
 * Return promised typedef of a given type if its missing
 *
 *c @access private
 * @param {string} typedef
 * @returns {string}
 */
function promisedType(typedef) {
    // istanbul ignore next
    if (!/^Promise</.test(typedef)) {
        typedef = `Promise<${typedef}>`;
    }
    return typedef;
}
/**
 * Removes Promise from type definition if any
 *
 * @access private
 * @param {string} typedef
 * @returns {string}
 */
function cleanType(typedef) {
    return typedef.replace(/^Promise<([\s\S]+?)>$/, '$1');
}
/**
 * Type to comment
 *
 * @access private
 * @param {string} typedef
 * @param {boolean} [promised]
 * @returns {string}
 */
function toComment(typedef, promised = false) {
    if (promised) {
        typedef = promisedType(typedef);
    }
    // istanbul ignore next
    return typedef.split(/\r?\n/)
        .map((line, lineNum) => (lineNum ? '         * ' : '') + line)
        .join('\n');
}
/**
 * Compiles client source code and returns loaded module
 *
 * @access private
 * @param {string} name
 * @param {string} src
 * @param {IMQClientOptions} options
 * @returns {any}
 */
async function compile(name, src, options) {
    const path = options.path;
    const srcFile = `${path}/${name}.ts`;
    const jsFile = `${path}/${name}.js`;
    const js = ts.transpile(src, tsOptions);
    if (options.write) {
        // istanbul ignore else
        if (!await _1.fileExists(path)) {
            await _1.mkdir(path);
        }
        await Promise.all([
            _1.writeFile(srcFile, src),
            _1.writeFile(jsFile, js),
        ]);
    }
    // istanbul ignore else
    if (options.compile) {
        const script = new vm.Script(js);
        const context = { exports: {}, require };
        script.runInNewContext(context, { filename: jsFile });
        return context.exports;
    }
    // istanbul ignore next
    return null;
}
//# sourceMappingURL=IMQClient.js.map