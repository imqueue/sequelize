"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/*!
 * IMQService implementation
 *
 * Copyright (c) 2018, imqueue.com <support@imqueue.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
const core_1 = require("@imqueue/core");
const _1 = require(".");
const cluster = require("cluster");
const os = require("os");
class Description {
}
exports.Description = Description;
let serviceDescription = null;
/**
 * Returns collection of class methods metadata even those are inherited
 * from a chain of parent classes
 *
 * @param {string} className
 * @return {MethodsCollectionDescription}
 */
function getClassMethods(className) {
    let methods = {};
    let classInfo = _1.IMQRPCDescription.serviceDescription[className];
    if (classInfo.inherits &&
        _1.IMQRPCDescription.serviceDescription[classInfo.inherits]) {
        Object.assign(methods, getClassMethods(classInfo.inherits));
    }
    Object.assign(methods, classInfo.methods);
    return methods;
}
/**
 * Checks if given args match given args description at least by args count
 *
 * @param {ArgDescription[]} argsInfo
 * @param {any[]} args
 * @returns {boolean}
 */
function isValidArgsCount(argsInfo, args) {
    // istanbul ignore next
    return (argsInfo.some(argInfo => argInfo.isOptional)
        ? argsInfo.length >= args.length
        : argsInfo.length === args.length);
}
/**
 * Class IMQService
 * Basic abstract service (server-side) implementation
 */
class IMQService {
    // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected
    /**
     * Class constructor
     *
     * @constructor
     * @param {Partial<IMQServiceOptions>} options
     * @param {string} [name]
     */
    constructor(options, name) {
        this.name = name || this.constructor.name;
        if (this.name === 'IMQService') {
            throw new TypeError('IMQService class is abstract and cannot ' +
                'be instantiated directly!');
        }
        this.options = Object.assign({}, _1.DEFAULT_IMQ_SERVICE_OPTIONS, options);
        this.logger = this.options.logger || /* istanbul ignore next */ console;
        this.imq = core_1.default.create(this.name, this.options);
        this.handleRequest = this.handleRequest.bind(this);
        this.imq.on('message', this.handleRequest);
    }
    /**
     * Handles incoming request and produces corresponding response
     *
     * @access private
     * @param {IMQRPCRequest} msg - request message
     * @param {string} id - message unique identifier
     * @return {Promise<string>}
     */
    async handleRequest(msg, id) {
        const method = msg.method;
        const description = await this.describe();
        const args = msg.args;
        let response = {
            to: id,
            data: null,
            error: null,
            request: msg
        };
        if (!this[method]) {
            response.error = _1.IMQError('IMQ_RPC_NO_METHOD', `Method ${this.name}.${method}() does not exist.`, new Error().stack, method, args);
        }
        else if (!description.service.methods[method]) {
            response.error = _1.IMQError('IMQ_RPC_NO_ACCESS', `Access to ${this.name}.${method}() denied!`, new Error().stack, method, args);
        }
        else if (!isValidArgsCount(description.service.methods[method].arguments, args)) {
            response.error = _1.IMQError('IMQ_RPC_INVALID_ARGS_COUNT', `Invalid args count for ${this.name}.${method}().`, new Error().stack, method, args);
        }
        if (response.error) {
            this.logger.warn(response.error);
            return await this.imq.send(msg.from, response);
        }
        try {
            response.data = this[method].apply(this, args);
            // istanbul ignore next
            if (response.data && response.data.then) {
                response.data = await response.data;
            }
        }
        catch (err) {
            response.error = _1.IMQError(err.code || 'IMQ_RPC_CALL_ERROR', err.message, err.stack, method, args);
        }
        return await this.imq.send(msg.from, response);
    }
    /**
     * Initializes this instance of service and starts handling request
     * messages.
     *
     * @return {Promise<IMessageQueue>}
     */
    async start() {
        if (!this.options.multiProcess) {
            this.logger.info('%s: starting single-worker, pid %s', this.name, process.pid);
            this.describe();
            return this.imq.start();
        }
        if (cluster.isMaster) {
            const numCpus = os.cpus().length;
            const numWorkers = numCpus * this.options.childrenPerCore;
            for (let i = 0; i < numWorkers; i++) {
                this.logger.info('%s: starting worker #%s ...', this.name, i);
                cluster.fork({ workerId: i });
            }
            // istanbul ignore next
            cluster.on('exit', (worker) => {
                this.logger.info('%s: worker pid %s died, exiting', this.name, worker.process.pid);
                process.exit(1);
            });
        }
        else {
            this.logger.info('%s: worker #%s started, pid %s', this.name, process.env['workerId'], process.pid);
            this.describe();
            return this.imq.start();
        }
    }
    /**
     * Stops service from handling messages
     *
     * @return {Promise<void>}
     */
    async stop() {
        await this.imq.stop();
    }
    /**
     * Destroys this instance of service
     *
     * @return {Promise<void>}
     */
    async destroy() {
        await this.imq.destroy();
    }
    /**
     * Returns service description metadata.
     *
     * @returns {Promise<Description>}
     */
    describe() {
        if (!serviceDescription) {
            serviceDescription = {
                service: {
                    name: this.name,
                    methods: getClassMethods(this.constructor.name)
                },
                types: _1.IMQRPCDescription.typesDescription
            };
        }
        return serviceDescription;
    }
}
__decorate([
    core_1.profile(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], IMQService.prototype, "start", null);
__decorate([
    core_1.profile(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], IMQService.prototype, "stop", null);
__decorate([
    core_1.profile(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], IMQService.prototype, "destroy", null);
__decorate([
    core_1.profile(),
    _1.expose(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Description)
], IMQService.prototype, "describe", null);
exports.IMQService = IMQService;
//# sourceMappingURL=IMQService.js.map