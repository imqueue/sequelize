"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*!
 * Decorator: @profile
 *
 * Copyright (c) 2018, imqueue.com <support@imqueue.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
const mt = require("microtime");
require("reflect-metadata");
/**
 * Environment variable IMQ_LOG_TIME=[1, 0] - enables/disables profiled
 * timings logging
 *
 * @type {boolean}
 */
exports.IMQ_LOG_TIME = !!process.env['IMQ_LOG_TIME'];
/**
 * Environment variable IMQ_LOG_ARGS=[1, 0] - enables/disables profiled
 * call arguments to be logged
 *
 * @type {boolean}
 */
exports.IMQ_LOG_ARGS = !!process.env['IMQ_LOG_ARGS'];
/**
 * Environment variable IMQ_LOG_TIME_FORMAT=[
 *   'microseconds',
 *   'milliseconds',
 *   'seconds'
 * ]. Specifies profiled time logging format, by default is 'microseconds'
 *
 * @type {AllowedTimeFormat | string}
 */
exports.IMQ_LOG_TIME_FORMAT = process.env['IMQ_LOG_TIME_FORMAT'] || 'microseconds';
/**
 * Prints debug information
 *
 * @param {boolean} debugTime
 * @param {boolean} debugArgs
 * @param {string} className
 * @param {any[]} args
 * @param {string} methodName
 * @param {number} start
 * @param {ILogger} logger
 */
function logDebugInfo({ debugTime, debugArgs, className, args, methodName, start, logger, }) {
    if (debugTime) {
        const time = mt.now() - start;
        let timeStr = '';
        // istanbul ignore next
        switch (exports.IMQ_LOG_TIME_FORMAT) {
            case 'milliseconds':
                timeStr = (time / 1000).toFixed(3) + ' ms';
                break;
            case 'seconds':
                timeStr = (time / 1000000).toFixed(3) + ' sec';
                break;
            default:
                timeStr = time + ' Î¼s';
                break;
        }
        logger.log(`${className}.${methodName}() executed in ${timeStr}`);
    }
    if (debugArgs) {
        let argStr = '';
        const cache = [];
        try {
            argStr = JSON.stringify(args, (key, value) => {
                if (typeof value === 'object' && value !== null) {
                    if (~cache.indexOf(value)) {
                        try {
                            return JSON.parse(JSON.stringify(value));
                        }
                        catch (error) {
                            return;
                        }
                    }
                    cache.push(value);
                }
                return value;
            }, 2);
        }
        catch (err) {
            logger.error(err);
        }
        logger.log(`${className}.${methodName}() called with args: ${argStr}`);
    }
}
exports.logDebugInfo = logDebugInfo;
/**
 * Implements '@profile' decorator.
 *
 * @example
 * ~~~typescript
 * import { profile } from '@imqueue/core';
 *
 * class MyClass {
 *
 *     @profile(true) // forced profiling
 *     public myMethod() {
 *         // ...
 *     }
 *
 *     @profile() // profiling happened only depending on env DEBUG flag
 *     private innerMethod() {
 *         // ...
 *     }
 * }
 * ~~~
 *
 * @return {(
 *  target: any,
 *  methodName: (string),
 *  descriptor: TypedPropertyDescriptor<(...args: any[]) => any>
 * ) => void}
 */
function profile(enableDebugTime, enableDebugArgs) {
    let debugTime = exports.IMQ_LOG_TIME;
    let debugArgs = exports.IMQ_LOG_ARGS;
    if (typeof enableDebugTime === 'boolean') {
        debugTime = enableDebugTime;
    }
    if (typeof enableDebugArgs === 'boolean') {
        debugArgs = enableDebugArgs;
    }
    return function wrapper(target, methodName, descriptor) {
        /* istanbul ignore next */
        const original = descriptor.value || target[methodName];
        descriptor.value = function (...args) {
            if (!(debugTime || debugArgs)) {
                return original.apply(this, args);
            }
            /* istanbul ignore next */
            const className = typeof target === 'function' && target.name
                ? target.name // static
                : target.constructor.name; // dynamic
            const start = mt.now();
            const result = original.apply(this, args);
            const debugOptions = {
                args,
                className,
                debugArgs,
                debugTime,
                logger: (this || target).logger,
                methodName,
                start,
            };
            /* istanbul ignore next */
            if (result && typeof result.then === 'function') {
                // async call detected
                result.then((res) => {
                    logDebugInfo(debugOptions);
                    return res;
                });
                return result;
            }
            logDebugInfo(debugOptions);
            return result;
        };
    };
}
exports.profile = profile;
//# sourceMappingURL=profile.js.map