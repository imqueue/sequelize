"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require(".");
/**
 * Class ClusteredRedisQueue
 * Implements possibility to scale queues horizontally between several
 * redis instances.
 */
class ClusteredRedisQueue {
    /**
     * Class constructor
     *
     * @constructor
     * @param {string} name
     * @param {Partial<IMQOptions>} options
     */
    constructor(name, options) {
        this.name = name;
        /**
         * RedisQueue instances collection
         *
         * @type {RedisQueue[]}
         */
        this.imqs = [];
        /**
         * Cluster servers option definitions
         *
         * @type {{ host: string, port: number }[]}
         */
        this.servers = [];
        /**
         * Current queue index (round-robin)
         *
         * @type {number}
         */
        this.currentQueue = 0;
        /**
         * Total length of RedisQueue instances
         *
         * @type {number}
         */
        this.queueLength = 0;
        this.options = _1.buildOptions(_1.DEFAULT_IMQ_OPTIONS, options);
        // istanbul ignore next
        this.logger = this.options.logger || console;
        if (!this.options.cluster) {
            throw new TypeError('ClusteredRedisQueue: cluster ' +
                'configuration is missing!');
        }
        this.mqOptions = Object.assign({}, this.options);
        // istanbul ignore next
        this.servers = this.mqOptions.cluster || [];
        delete this.mqOptions.cluster;
        for (let i = 0, s = this.servers.length; i < s; i++) {
            const opts = Object.assign({}, this.mqOptions, this.servers[i]);
            this.imqs.push(new _1.RedisQueue(this.name, opts));
        }
        this.queueLength = this.imqs.length;
    }
    /**
     * Starts the messaging queue.
     * Supposed to be an async function.
     *
     * @returns {Promise<ClusteredRedisQueue>}
     */
    async start() {
        return await this.batch('start', 'Starting clustered redis message queue...');
    }
    /**
     * Stops the queue (should stop handle queue messages).
     * Supposed to be an async function.
     *
     * @returns {Promise<ClusteredRedisQueue>}
     */
    async stop() {
        return await this.batch('stop', 'Stopping clustered redis message queue...');
    }
    /**
     * Sends a message to given queue name with the given data.
     * Supposed to be an async function.
     *
     * @param {string} toQueue - queue name to which message should be sent to
     * @param {IJson} message - message data
     * @param {number} [delay] - if specified, message will be handled in the
     *        target queue after specified period of time in milliseconds.
     * @param {(err: Error) => void} [errorHandler] - callback called only when
     *        internal error occurs during message send execution.
     * @returns {Promise<string>} - message identifier
     */
    async send(toQueue, message, delay, errorHandler) {
        if (this.currentQueue >= this.queueLength) {
            this.currentQueue = 0;
        }
        const imq = this.imqs[this.currentQueue];
        const id = await imq.send(toQueue, message, delay, errorHandler);
        this.currentQueue++;
        return id;
    }
    /**
     * Safely destroys current queue, unregistered all set event
     * listeners and connections.
     * Supposed to be an async function.
     *
     * @returns {Promise<void>}
     */
    async destroy() {
        await this.batch('destroy', 'Destroying clustered redis message queue...');
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * Clears queue data in queue host application.
     * Supposed to be an async function.
     *
     * @returns {Promise<ClusteredRedisQueue>}
     */
    async clear() {
        return await this.batch('clear', 'Clearing clustered redis message queue...');
    }
    /**
     * Batch imq action processing on all registered imqs at once
     *
     * @access private
     * @param {string} action
     * @param {string} message
     * @return {Promise<this>}
     */
    async batch(action, message) {
        this.logger.log(message);
        const promises = [];
        for (const imq of this.imqs) {
            promises.push(imq[action]());
        }
        await Promise.all(promises);
        return this;
    }
    /* tslint:disable */
    // EventEmitter interface
    // istanbul ignore next
    on(...args) {
        for (let imq of this.imqs) {
            imq.on.apply(imq, args);
        }
        return this;
    }
    // istanbul ignore next
    // noinspection JSUnusedGlobalSymbols
    off(...args) {
        for (let imq of this.imqs) {
            imq.off.apply(imq, args);
        }
        return this;
    }
    // istanbul ignore next
    once(...args) {
        for (let imq of this.imqs) {
            imq.once.apply(imq, args);
        }
        return this;
    }
    // istanbul ignore next
    addListener(...args) {
        for (let imq of this.imqs) {
            imq.addListener.apply(imq, args);
        }
        return this;
    }
    // istanbul ignore next
    removeListener(...args) {
        for (let imq of this.imqs) {
            imq.removeListener.apply(imq, args);
        }
        return this;
    }
    // istanbul ignore next
    removeAllListeners(...args) {
        for (let imq of this.imqs) {
            imq.removeAllListeners.apply(imq, args);
        }
        return this;
    }
    // istanbul ignore next
    prependListener(...args) {
        for (let imq of this.imqs) {
            imq.prependListener.apply(imq, args);
        }
        return this;
    }
    // istanbul ignore next
    prependOnceListener(...args) {
        for (let imq of this.imqs) {
            imq.prependOnceListener.apply(imq, args);
        }
        return this;
    }
    // istanbul ignore next
    setMaxListeners(...args) {
        for (let imq of this.imqs) {
            imq.setMaxListeners.apply(imq, args);
        }
        return this;
    }
    // istanbul ignore next
    listeners(...args) {
        let listeners = [];
        for (let imq of this.imqs) {
            listeners = listeners.concat(imq.listeners.apply(imq, args));
        }
        return listeners;
    }
    // istanbul ignore next
    rawListeners(...args) {
        let rawListeners = [];
        for (let imq of this.imqs) {
            rawListeners = rawListeners.concat(imq.rawListeners.apply(imq, args));
        }
        return rawListeners;
    }
    // istanbul ignore next
    getMaxListeners() {
        return this.imqs[0].getMaxListeners();
    }
    // istanbul ignore next
    emit(...args) {
        for (let imq of this.imqs) {
            imq.emit.apply(imq, args);
        }
        return true;
    }
    // istanbul ignore next
    eventNames(...args) {
        return this.imqs[0].eventNames.apply(this.imqs[0], args);
    }
    // istanbul ignore next
    listenerCount(...args) {
        return this.imqs[0].listenerCount.apply(this.imqs[0], args);
    }
}
exports.ClusteredRedisQueue = ClusteredRedisQueue;
//# sourceMappingURL=ClusteredRedisQueue.js.map