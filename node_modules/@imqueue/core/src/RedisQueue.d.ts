/// <reference types="node" />
import { EventEmitter } from 'events';
import { IJson, IMessageQueue, IMQOptions } from '.';
export declare const DEFAULT_IMQ_OPTIONS: IMQOptions;
/**
 * Returns SHA1 hash sum of the given string
 *
 * @param {string} str
 * @returns {string}
 */
export declare function sha1(str: string): string;
/**
 * Returns random integer between given min and max
 *
 * @param {number} min
 * @param {number} max
 * @returns {number}
 */
export declare function intrand(min: number, max: number): number;
/**
 * Compress given data and returns binary string
 *
 * @param {any} data
 * @returns {string}
 */
export declare function pack(data: any): string;
/**
 * Decompress binary string and returns plain data
 *
 * @param {string} data
 * @returns {any}
 */
export declare function unpack(data: string): any;
/**
 * Class RedisQueue
 * Implements simple messaging queue over redis.
 */
export declare class RedisQueue extends EventEmitter implements IMessageQueue {
    name: string;
    /**
     * Writer connections collection
     *
     * @type {{}}
     */
    private static writers;
    /**
     * Watcher connections collection
     *
     * @type {{}}
     */
    private static watchers;
    [name: string]: any;
    /**
     * @event message (message: IJson, id: string, from: string)
     */
    /**
     * This queue instance options
     *
     * @type {IMQOptions}
     */
    options: IMQOptions;
    /**
     * Reader connection associated with this queue instance
     *
     * @type {IRedisClient}
     */
    private reader;
    /**
     * Init state for this queue instance
     *
     * @type {boolean}
     */
    private initialized;
    /**
     * True if current instance owns watcher connection, false otherwise
     *
     * @type {boolean}
     */
    private watchOwner;
    /**
     * Signals initialization state
     *
     * @type {boolean}
     */
    private signalsInitialized;
    /**
     * Will store check interval reference
     */
    private safeCheckInterval;
    /**
     * This queue instance unique key (identifier), for internal use
     */
    private readonly redisKey;
    /**
     * Writer connection associated with this queue instance
     *
     * @type {IRedisClient}
     */
    /**
    * Writer connection setter.
    *
    * @param {IRedisClient} conn
    */
    private writer;
    /**
     * Watcher connection instance associated with this queue instance
     *
     * @type {IRedisClient}
     */
    /**
    * Watcher setter, sets the watcher connection property for this
    * queue instance
    *
    * @param {IRedisClient} conn
    */
    private watcher;
    /**
     * Logger instance associated with current queue instance
     * @type {ILogger}
     */
    private readonly logger;
    /**
     * LUA scripts for redis
     *
     * @type {{moveDelayed: {code: string}}}
     */
    private scripts;
    /**
     * Return a lock key for watcher connection
     *
     * @access private
     * @returns {string}
     */
    private readonly lockKey;
    /**
     * Returns current queue key
     *
     * @access private
     * @returns {string}
     */
    private readonly key;
    /**
     * Serializes given data object into string
     *
     * @param {any} data
     * @returns {string}
     */
    private readonly pack;
    /**
     * Deserialize string data into object
     *
     * @param {string} data
     * @returns {any}
     */
    private readonly unpack;
    /**
     * @constructor
     * @param {string} name
     * @param {IMQOptions} [options]
     */
    constructor(name: string, options?: Partial<IMQOptions>);
    /**
     * Initializes and starts current queue routines
     *
     * @returns {Promise<RedisQueue>}
     */
    start(): Promise<RedisQueue>;
    /**
     * Sends given message to a given queue (by name)
     *
     * @param {string} toQueue
     * @param {IJson} message
     * @param {number} [delay]
     * @param {(err: Error) => void} [errorHandler]
     * @returns {Promise<RedisQueue>}
     */
    send(toQueue: string, message: IJson, delay?: number, errorHandler?: (err: Error) => void): Promise<string>;
    /**
     * Stops current queue routines
     *
     * @returns {Promise<RedisQueue>}
     */
    stop(): Promise<RedisQueue>;
    /**
     * Destroys watcher channel
     *
     * @access private
     */
    private destroyWatcher;
    /**
     * Destroys writer channel
     *
     * @access private
     */
    private destroyWriter;
    /**
     * Gracefully destroys this queue
     *
     * @returns {Promise<void>}
     */
    destroy(): Promise<void>;
    /**
     * Clears queue data in redis;
     *
     * @returns {Promise<void>}
     */
    clear(): Promise<RedisQueue>;
    /**
     * Establishes given connection channel by its' name
     *
     * @access private
     * @param {"reader" | "writer" | "watcher"} channel
     * @param {IMQOptions} options
     * @param {any} context
     * @returns {Promise<any>}
     */
    private connect;
    /**
     * Builds and returns connection ready state handler
     *
     * @access private
     * @param {IMQOptions} options
     * @param {any} context
     * @param {string} channel
     * @param {(...args: any[]) => void} resolve
     * @return {() => Promise<void>}
     */
    private onReadyHandler;
    /**
     * Sets channel name
     *
     * @param {IRedisClient} channel
     * @param {string} contextName
     * @param {string} prefix
     * @param {string} name
     */
    private setChannelName;
    /**
     * Builds and returns redis connection reconnect handler
     *
     * @access private
     * @param {any} context
     * @param {string} channel
     * @return {() => void}
     */
    private onReconnectHandler;
    /**
     * Builds and returns connection error handler
     *
     * @access private
     * @param context
     * @param {string} channel
     * @param {(...args: any[]) => void} reject
     * @return {(err: Error) => void}
     */
    private onErrorHandler;
    /**
     * Builds and returns redis connection close handler
     *
     * @access private
     * @param {any} context
     * @param {string} channel
     * @return {(...args: any[]) => any}
     */
    private onCloseHandler;
    /**
     * Processes given redis-queue message
     *
     * @access private
     * @param {[any , any]} msg
     * @returns {RedisQueue}
     */
    private process;
    /**
     * Returns number of established watcher connections on redis
     *
     * @access private
     * @returns {Promise<number>}
     */
    private watcherCount;
    /**
     * Processes delayed message by its given redis key
     *
     * @access private
     * @param {string} key
     * @returns {Promise<void>}
     */
    private processDelayed;
    /**
     * Watch routine
     *
     * @access private
     * @return {Promise<any>}
     */
    private processWatch;
    /**
     * Process given keys from a message queue
     *
     * @access private
     * @param {string[]} keys
     * @param {number} now
     * @return {Promise<void>}
     */
    private processKeys;
    /**
     * Watch message processor
     *
     * @access private
     * @param {...any[]} args
     * @return {Promise<void>}
     */
    private onWatchMessage;
    /**
     * Clears safe check interval
     *
     * @access private
     */
    private cleanSafeCheckInterval;
    /**
     * Setups watch process on delayed messages
     *
     * @access private
     * @returns {RedisQueue}
     */
    private watch;
    /**
     * Cleans up orphaned keys from redis
     *
     * @access private
     * @returns {RedisQueue}
     */
    private processCleanup;
    /**
     * Unreliable but fast way of message handling by the queue
     */
    private readUnsafe;
    /**
     * Reliable but slow method of message handling by message queue
     */
    private readSafe;
    /**
     * Initializes read process on redis message queue
     *
     * @returns {RedisQueue}
     */
    private read;
    /**
     * Checks if watcher connection is locked
     *
     * @access private
     * @returns {Promise<boolean>}
     */
    private isLocked;
    /**
     * Locks watcher connection
     *
     * @access private
     * @returns {Promise<boolean>}
     */
    private lock;
    /**
     * Unlocks watcher connection
     *
     * @access private
     * @returns {Promise<boolean>}
     */
    private unlock;
    /**
     * Emits error
     *
     * @access private
     * @param {string} eventName
     * @param {string} message
     * @param {Error} err
     */
    private emitError;
    /**
     * Acquires owner for watcher connection to this instance of the queue
     *
     * @returns {Promise<void>}
     */
    private ownWatch;
    /**
     * Returns watcher lock resolver function
     *
     * @access private
     * @param {(...args: any[]) => void} resolve
     * @param {(...args: any[]) => void} reject
     * @return {() => Promise<any>}
     */
    private watchLockResolver;
    /**
     * Initializes single watcher connection across all queues with the same
     * prefix.
     *
     * @returns {Promise<void>}
     */
    private initWatcher;
}
