"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/*!
 * Fast messaging queue over Redis
 *
 * Copyright (c) 2018, imqueue.com <support@imqueue.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
const crypto = require("crypto");
const events_1 = require("events");
const os = require("os");
const zlib_1 = require("zlib");
const _1 = require(".");
const RX_CLIENT_NAME = /name=(\S+)/g;
const RX_CLIENT_TEST = /:(reader|writer|watcher)/;
const RX_CLIENT_CLEAN = /:(reader|writer|watcher).*$/;
exports.DEFAULT_IMQ_OPTIONS = {
    cleanup: false,
    cleanupFilter: '*',
    host: 'localhost',
    logger: console,
    port: 6379,
    prefix: 'imq',
    safeDelivery: false,
    safeDeliveryTtl: 5000,
    useGzip: false,
    watcherCheckDelay: 5000,
};
/**
 * Returns SHA1 hash sum of the given string
 *
 * @param {string} str
 * @returns {string}
 */
function sha1(str) {
    const sha = crypto.createHash('sha1');
    sha.update(str);
    return sha.digest('hex');
}
exports.sha1 = sha1;
/**
 * Returns random integer between given min and max
 *
 * @param {number} min
 * @param {number} max
 * @returns {number}
 */
function intrand(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
exports.intrand = intrand;
/**
 * Compress given data and returns binary string
 *
 * @param {any} data
 * @returns {string}
 */
// istanbul ignore next
function pack(data) {
    return zlib_1.gzipSync(JSON.stringify(data)).toString('binary');
}
exports.pack = pack;
/**
 * Decompress binary string and returns plain data
 *
 * @param {string} data
 * @returns {any}
 */
// istanbul ignore next
function unpack(data) {
    return JSON.parse(zlib_1.gunzipSync(Buffer.from(data, 'binary')).toString());
}
exports.unpack = unpack;
/**
 * Class RedisQueue
 * Implements simple messaging queue over redis.
 */
class RedisQueue extends events_1.EventEmitter {
    /**
     * @constructor
     * @param {string} name
     * @param {IMQOptions} [options]
     */
    constructor(name, options) {
        super();
        this.name = name;
        /**
         * Init state for this queue instance
         *
         * @type {boolean}
         */
        this.initialized = false;
        /**
         * True if current instance owns watcher connection, false otherwise
         *
         * @type {boolean}
         */
        this.watchOwner = false;
        /**
         * Signals initialization state
         *
         * @type {boolean}
         */
        this.signalsInitialized = false;
        /**
         * LUA scripts for redis
         *
         * @type {{moveDelayed: {code: string}}}
         */
        this.scripts = {
            moveDelayed: {
                code: 'local messages = redis.call(' +
                    '"zrangebyscore", KEYS[1], "-inf", ARGV[1]) ' +
                    'local count = table.getn(messages) ' +
                    'local message ' +
                    'local i = 1 ' +
                    'if count > 0 then ' +
                    'while messages[i] do ' +
                    'redis.call("lpush", KEYS[2], messages[i]) ' +
                    'i = i + 1 ' +
                    'end ' +
                    'redis.call("zremrangebyscore", KEYS[1], ' +
                    '"-inf", ARGV[1]) ' +
                    'end ' +
                    'return count',
            },
        };
        this.options = _1.buildOptions(exports.DEFAULT_IMQ_OPTIONS, options);
        /* tslint:disable */
        this.pack = this.options.useGzip ? pack : JSON.stringify;
        this.unpack = this.options.useGzip ? unpack : JSON.parse;
        /* tslint:enable */
        this.redisKey = `${this.options.host}:${this.options.port}`;
    }
    // noinspection JSMethodCanBeStatic
    /**
     * Writer connection associated with this queue instance
     *
     * @type {IRedisClient}
     */
    get writer() {
        return RedisQueue.writers[this.redisKey];
    }
    /**
     * Writer connection setter.
     *
     * @param {IRedisClient} conn
     */
    // noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols
    set writer(conn) {
        RedisQueue.writers[this.redisKey] = conn;
    }
    /**
     * Watcher connection instance associated with this queue instance
     *
     * @type {IRedisClient}
     */
    get watcher() {
        return RedisQueue.watchers[this.redisKey];
    }
    /**
     * Watcher setter, sets the watcher connection property for this
     * queue instance
     *
     * @param {IRedisClient} conn
     */
    // noinspection JSUnusedLocalSymbols
    set watcher(conn) {
        RedisQueue.watchers[this.redisKey] = conn;
    }
    /**
     * Logger instance associated with current queue instance
     * @type {ILogger}
     */
    get logger() {
        // istanbul ignore next
        return this.options.logger || console;
    }
    /**
     * Return a lock key for watcher connection
     *
     * @access private
     * @returns {string}
     */
    get lockKey() {
        return `${this.options.prefix}:watch:lock`;
    }
    /**
     * Returns current queue key
     *
     * @access private
     * @returns {string}
     */
    get key() {
        return `${this.options.prefix}:${this.name}`;
    }
    /**
     * Initializes and starts current queue routines
     *
     * @returns {Promise<RedisQueue>}
     */
    async start() {
        if (!this.name) {
            throw new TypeError(`${this.name}: No queue name provided!`);
        }
        if (this.initialized) {
            return this;
        }
        const connPromises = [];
        // istanbul ignore next
        if (!this.reader) {
            connPromises.push(this.connect('reader', this.options));
        }
        if (!this.writer) {
            connPromises.push(this.connect('writer', this.options));
        }
        await Promise.all(connPromises);
        if (!this.signalsInitialized) {
            // istanbul ignore next
            const free = async () => {
                if (this.watchOwner) {
                    await this.unlock();
                }
                process.exit(0);
            };
            process.on('SIGTERM', free);
            process.on('SIGINT', free);
            this.signalsInitialized = true;
        }
        await this.initWatcher();
        this.initialized = true;
        return this;
    }
    /**
     * Sends given message to a given queue (by name)
     *
     * @param {string} toQueue
     * @param {IJson} message
     * @param {number} [delay]
     * @param {(err: Error) => void} [errorHandler]
     * @returns {Promise<RedisQueue>}
     */
    async send(toQueue, message, delay, errorHandler) {
        // istanbul ignore next
        if (!this.writer) {
            await this.start();
        }
        const id = _1.uuid();
        const data = { id, message, from: this.name };
        const key = `${this.options.prefix}:${toQueue}`;
        const packet = this.pack(data);
        const cb = (error) => {
            // istanbul ignore next
            if (error && errorHandler) {
                errorHandler(error);
            }
        };
        if (delay) {
            this.writer.zadd(`${key}:delayed`, Date.now() + delay, packet, (err) => {
                // istanbul ignore next
                if (err) {
                    cb(err);
                    return;
                }
                this.writer.set(`${key}:${id}:ttl`, '', 'PX', delay, 'NX', cb);
            });
        }
        else {
            this.writer.lpush(key, packet, cb);
        }
        return id;
    }
    /**
     * Stops current queue routines
     *
     * @returns {Promise<RedisQueue>}
     */
    async stop() {
        if (this.reader) {
            this.reader.removeAllListeners();
            this.reader.end(false);
            this.reader.unref();
            delete this.reader;
        }
        this.initialized = false;
        return this;
    }
    /**
     * Destroys watcher channel
     *
     * @access private
     */
    destroyWatcher() {
        if (this.watcher) {
            this.watcher.removeAllListeners();
            this.watcher.end(false);
            this.watcher.unref();
            delete RedisQueue.watchers[this.redisKey];
        }
    }
    /**
     * Destroys writer channel
     *
     * @access private
     */
    destroyWriter() {
        if (this.writer) {
            this.writer.removeAllListeners();
            this.writer.end(false);
            this.writer.unref();
            delete RedisQueue.writers[this.redisKey];
        }
    }
    /**
     * Gracefully destroys this queue
     *
     * @returns {Promise<void>}
     */
    async destroy() {
        this.removeAllListeners();
        this.cleanSafeCheckInterval();
        this.destroyWatcher();
        await this.stop();
        await this.clear();
        this.destroyWriter();
    }
    /**
     * Clears queue data in redis;
     *
     * @returns {Promise<void>}
     */
    async clear() {
        if (!this.writer) {
            return this;
        }
        await Promise.all([
            this.writer.del(this.key),
            this.writer.del(`${this.key}:delayed`),
        ]);
        return this;
    }
    /**
     * Establishes given connection channel by its' name
     *
     * @access private
     * @param {"reader" | "writer" | "watcher"} channel
     * @param {IMQOptions} options
     * @param {any} context
     * @returns {Promise<any>}
     */
    async connect(channel, options, context = this) {
        // istanbul ignore next
        if (context[channel]) {
            return context[channel];
        }
        return new Promise((resolve, reject) => {
            context[channel] = _1.redis.createClient(
            // istanbul ignore next
            options.port || 6379, 
            // istanbul ignore next
            options.host || 'localhost');
            context[channel].on('ready', this.onReadyHandler(options, context, channel, resolve));
            context[channel].on('error', this.onErrorHandler(context, channel, reject));
            context[channel].on('end', this.onCloseHandler(context, channel));
            context[channel].on('reconnecting', this.onReconnectHandler(context, channel));
        });
    }
    /**
     * Builds and returns connection ready state handler
     *
     * @access private
     * @param {IMQOptions} options
     * @param {any} context
     * @param {string} channel
     * @param {(...args: any[]) => void} resolve
     * @return {() => Promise<void>}
     */
    onReadyHandler(options, context, channel, resolve) {
        return (async () => {
            this.logger.info('%s: %s channel connected, host %s, pid %s', context.name, channel, this.redisKey, process.pid);
            await this.setChannelName(context[channel], context.name, options.prefix || '', channel);
            switch (channel) {
                case 'reader':
                    this.read();
                    break;
                case 'writer':
                    await this.processDelayed(this.key);
                    break;
                case 'watcher':
                    await this.initWatcher();
                    break;
            }
            resolve(context[channel]);
        });
    }
    /**
     * Sets channel name
     *
     * @param {IRedisClient} channel
     * @param {string} contextName
     * @param {string} prefix
     * @param {string} name
     */
    async setChannelName(channel, contextName, prefix, name) {
        await channel.client('setname', `${prefix}:${contextName}:${name}:pid:${process.pid}:host:${os.hostname()}`);
    }
    /**
     * Builds and returns redis connection reconnect handler
     *
     * @access private
     * @param {any} context
     * @param {string} channel
     * @return {() => void}
     */
    onReconnectHandler(context, channel) {
        // istanbul ignore next
        return (async () => {
            if (channel === 'watcher') {
                await context[channel].punsubscribe();
                this.watcher.__ready__ = false;
                this.cleanSafeCheckInterval();
            }
            this.initialized = false;
            this.logger.warn('%s: redis connection %s is reconnecting on host %s, ' +
                'pid %s...', context.name, channel, this.redisKey, process.pid);
        });
    }
    /**
     * Builds and returns connection error handler
     *
     * @access private
     * @param context
     * @param {string} channel
     * @param {(...args: any[]) => void} reject
     * @return {(err: Error) => void}
     */
    onErrorHandler(context, channel, reject) {
        // istanbul ignore next
        return ((err) => {
            this.initialized = false;
            this.logger.error(`${context.name}: error connecting redis host ${this.redisKey} on ${channel}, pid ${process.pid}:`, err);
            reject(err);
        });
    }
    /**
     * Builds and returns redis connection close handler
     *
     * @access private
     * @param {any} context
     * @param {string} channel
     * @return {(...args: any[]) => any}
     */
    onCloseHandler(context, channel) {
        // istanbul ignore next
        return (() => {
            this.initialized = false;
            this.logger.warn('%s: redis connection %s closed on host %s, pid %s!', context.name, channel, this.redisKey, process.pid);
        });
    }
    /**
     * Processes given redis-queue message
     *
     * @access private
     * @param {[any , any]} msg
     * @returns {RedisQueue}
     */
    process(msg) {
        const [queue, data] = msg;
        // istanbul ignore next
        if (!queue || queue !== this.key) {
            return this;
        }
        try {
            const { id, message, from } = this.unpack(data);
            this.emit('message', message, id, from);
        }
        catch (err) {
            // istanbul ignore next
            this.emitError('OnMessage', 'process error - message is invalid', err);
        }
        return this;
    }
    /**
     * Returns number of established watcher connections on redis
     *
     * @access private
     * @returns {Promise<number>}
     */
    // istanbul ignore next
    async watcherCount() {
        const rx = new RegExp(`\\bname=${this.options.prefix}:[\\S]+?:watcher:`);
        return (await this.writer.client('list') || '')
            .split(/\r?\n/)
            .filter((client) => rx.test(client))
            .length;
    }
    /**
     * Processes delayed message by its given redis key
     *
     * @access private
     * @param {string} key
     * @returns {Promise<void>}
     */
    async processDelayed(key) {
        try {
            if (this.scripts.moveDelayed.checksum) {
                await this.writer.evalsha(this.scripts.moveDelayed.checksum, 2, `${key}:delayed`, key, Date.now());
            }
        }
        catch (err) {
            this.emitError('OnProcessDelayed', 'error processing delayed queue', err);
        }
    }
    // istanbul ignore next
    /**
     * Watch routine
     *
     * @access private
     * @return {Promise<any>}
     */
    async processWatch() {
        const now = Date.now();
        let cursor = '0';
        while (true) {
            try {
                const data = await this.writer.scan(cursor, 'match', `${this.options.prefix}:*:worker:*`, 'count', '1000');
                cursor = data.shift();
                await this.processKeys(data.shift() || [], now);
                if (cursor === '0') {
                    return;
                }
            }
            catch (err) {
                this.emitError('OnSafeDelivery', 'safe queue message delivery problem', err);
                this.cleanSafeCheckInterval();
                return;
            }
        }
    }
    // istanbul ignore next
    /**
     * Process given keys from a message queue
     *
     * @access private
     * @param {string[]} keys
     * @param {number} now
     * @return {Promise<void>}
     */
    async processKeys(keys, now) {
        if (!keys.length) {
            return;
        }
        for (const key of keys) {
            const kp = key.split(':');
            if (Number(kp.pop()) < now) {
                continue;
            }
            await this.writer.rpoplpush(key, `${kp.shift()}:${kp.shift()}`);
        }
    }
    // istanbul ignore next
    /**
     * Watch message processor
     *
     * @access private
     * @param {...any[]} args
     * @return {Promise<void>}
     */
    async onWatchMessage(...args) {
        try {
            const key = args.pop().split(':');
            if (key.pop() !== 'ttl') {
                return;
            }
            key.pop(); // msg id
            await this.processDelayed(key.join(':'));
        }
        catch (err) {
            this.emitError('OnWatch', 'watch error', err);
        }
    }
    // istanbul ignore next
    /**
     * Clears safe check interval
     *
     * @access private
     */
    cleanSafeCheckInterval() {
        if (this.safeCheckInterval) {
            clearInterval(this.safeCheckInterval);
            delete this.safeCheckInterval;
        }
    }
    /**
     * Setups watch process on delayed messages
     *
     * @access private
     * @returns {RedisQueue}
     */
    // istanbul ignore next
    watch() {
        if (!this.watcher || this.watcher.__ready__) {
            return this;
        }
        try {
            this.writer.config('set', 'notify-keyspace-events', 'Ex');
        }
        catch (err) {
            this.emitError('OnConfig', 'events config error', err);
        }
        this.watcher.on('pmessage', this.onWatchMessage.bind(this));
        this.watcher.psubscribe('__keyevent@0__:expired', `${this.options.prefix}:delayed:*`);
        // watch for expired unhandled safe queues
        if (!this.safeCheckInterval) {
            this.safeCheckInterval = setInterval(async () => {
                if (!this.writer) {
                    this.cleanSafeCheckInterval();
                    return;
                }
                if (this.options.safeDelivery) {
                    await this.processWatch();
                }
                await this.processCleanup();
            }, this.options.safeDeliveryTtl);
        }
        this.watcher.__ready__ = true;
        return this;
    }
    /**
     * Cleans up orphaned keys from redis
     *
     * @access private
     * @returns {RedisQueue}
     */
    async processCleanup() {
        try {
            if (!this.options.cleanup) {
                return;
            }
            const filter = new RegExp(this.options.prefix + ':' +
                (this.options.cleanupFilter || '*').replace(/\*/g, '.*'), 'i');
            const clients = await this.writer.client('list');
            const connectedKeys = (clients.match(RX_CLIENT_NAME) || [])
                .filter((name) => RX_CLIENT_TEST.test(name) && filter.test(name))
                .map((name) => name
                .replace(/^name=/, '')
                .replace(RX_CLIENT_CLEAN, ''))
                .filter((name, i, a) => a.indexOf(name) === i);
            const keysToRemove = [];
            let cursor = '0';
            while (true) {
                const data = await this.writer.scan(cursor, 'match', `${this.options.prefix}:${this.options.cleanupFilter || '*'}`, 'count', '1000');
                cursor = data.shift();
                keysToRemove.push(...data.shift().filter((key) => key !== this.lockKey &&
                    connectedKeys.every((connectedKey) => key.indexOf(connectedKey) === -1)));
                if (cursor === '0') {
                    break;
                }
            }
            if (keysToRemove.length) {
                await this.writer.del(...keysToRemove);
            }
        }
        catch (err) {
            this.logger.warn('Clean-up error occurred:', err);
        }
        return this;
    }
    /**
     * Unreliable but fast way of message handling by the queue
     */
    async readUnsafe() {
        try {
            const key = this.key;
            while (true) {
                if (!this.reader) {
                    break;
                }
                try {
                    const msg = await this.reader.brpop(key, 0);
                    this.process(msg);
                }
                catch (err) {
                    // istanbul ignore next
                    if (err.message.match(/Stream connection ended/)) {
                        break;
                    }
                    // istanbul ignore next
                    // noinspection ExceptionCaughtLocallyJS
                    throw err;
                }
            }
        }
        catch (err) {
            // istanbul ignore next
            this.emitError('OnReadUnsafe', 'unsafe reader failed', err);
        }
    }
    /**
     * Reliable but slow method of message handling by message queue
     */
    async readSafe() {
        try {
            const key = this.key;
            while (true) {
                const expire = Date.now() +
                    Number(this.options.safeDeliveryTtl);
                const workerKey = `${key}:worker:${_1.uuid()}:${expire}`;
                if (!this.reader || !this.writer) {
                    break;
                }
                try {
                    await this.reader.brpoplpush(this.key, workerKey, 0);
                }
                catch (err) {
                    // istanbul ignore next
                    break;
                }
                const msgArr = await this.writer.lrange(workerKey, -1, 1);
                if (msgArr.length !== 1) {
                    throw new Error('Wrong messages count');
                }
                const msg = msgArr[0];
                this.process([key, msg]);
                this.writer.del(workerKey);
            }
        }
        catch (err) {
            // istanbul ignore next
            this.emitError('OnReadSafe', 'safe reader failed', err);
        }
    }
    /**
     * Initializes read process on redis message queue
     *
     * @returns {RedisQueue}
     */
    read() {
        // istanbul ignore next
        if (!this.reader) {
            this.logger.error(`${this.name}: reader connection is not initialized, pid ${process.pid} on redis host ${this.redisKey}!`);
            return this;
        }
        const readMethod = this.options.safeDelivery
            ? 'readSafe'
            : 'readUnsafe';
        process.nextTick(this[readMethod].bind(this));
        return this;
    }
    /**
     * Checks if watcher connection is locked
     *
     * @access private
     * @returns {Promise<boolean>}
     */
    async isLocked() {
        return !!Number(await this.writer.exists(this.lockKey));
    }
    /**
     * Locks watcher connection
     *
     * @access private
     * @returns {Promise<boolean>}
     */
    async lock() {
        return !!Number(await this.writer.setnx(this.lockKey, ''));
    }
    /**
     * Unlocks watcher connection
     *
     * @access private
     * @returns {Promise<boolean>}
     */
    async unlock() {
        return !!Number(await this.writer.del(this.lockKey));
    }
    // istanbul ignore next
    /**
     * Emits error
     *
     * @access private
     * @param {string} eventName
     * @param {string} message
     * @param {Error} err
     */
    emitError(eventName, message, err) {
        this.emit('error', err, eventName);
        this.logger.error(`${this.name}: ${message}, pid ${process.pid} on redis host ${this.redisKey}:`, err);
    }
    /**
     * Acquires owner for watcher connection to this instance of the queue
     *
     * @returns {Promise<void>}
     */
    // istanbul ignore next
    async ownWatch() {
        const owned = await this.lock();
        if (owned) {
            Object.keys(this.scripts).forEach(async (script) => {
                try {
                    const checksum = this.scripts[script].checksum = sha1(this.scripts[script].code);
                    const loaded = ((await this.writer.script('exists', checksum)) || []).shift();
                    if (!loaded) {
                        await this.writer.script('load', this.scripts[script].code);
                    }
                }
                catch (err) {
                    this.emitError('OnScriptLoad', 'script load error', err);
                }
            });
            this.watchOwner = true;
            await this.connect('watcher', this.options);
            this.watch();
        }
    }
    // istanbul ignore next
    /**
     * Returns watcher lock resolver function
     *
     * @access private
     * @param {(...args: any[]) => void} resolve
     * @param {(...args: any[]) => void} reject
     * @return {() => Promise<any>}
     */
    watchLockResolver(resolve, reject) {
        return (async () => {
            try {
                const noWatcher = !await this.watcherCount();
                if (await this.isLocked() && noWatcher) {
                    await this.unlock();
                    await this.ownWatch();
                }
                resolve();
            }
            catch (err) {
                reject(err);
            }
        });
    }
    /**
     * Initializes single watcher connection across all queues with the same
     * prefix.
     *
     * @returns {Promise<void>}
     */
    // istanbul ignore next
    async initWatcher() {
        return new Promise(async (resolve, reject) => {
            try {
                if (!await this.watcherCount()) {
                    await this.ownWatch();
                    if (this.watchOwner && this.watcher) {
                        resolve();
                    }
                    else {
                        // check for possible dead-lock to resolve
                        setTimeout(this.watchLockResolver(resolve, reject), intrand(1, 50));
                    }
                }
                else {
                    resolve();
                }
            }
            catch (err) {
                this.logger.error(`${this.name}: error initializing watcher, pid ${process.pid} on redis host ${this.redisKey}`, err);
                reject(err);
            }
        });
    }
}
/**
 * Writer connections collection
 *
 * @type {{}}
 */
RedisQueue.writers = {};
/**
 * Watcher connections collection
 *
 * @type {{}}
 */
RedisQueue.watchers = {};
__decorate([
    _1.profile(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], RedisQueue.prototype, "start", null);
__decorate([
    _1.profile(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Number, Function]),
    __metadata("design:returntype", Promise)
], RedisQueue.prototype, "send", null);
__decorate([
    _1.profile(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], RedisQueue.prototype, "stop", null);
__decorate([
    _1.profile(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], RedisQueue.prototype, "destroyWatcher", null);
__decorate([
    _1.profile(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], RedisQueue.prototype, "destroyWriter", null);
__decorate([
    _1.profile(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], RedisQueue.prototype, "destroy", null);
__decorate([
    _1.profile(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], RedisQueue.prototype, "clear", null);
__decorate([
    _1.profile(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], RedisQueue.prototype, "connect", null);
__decorate([
    _1.profile(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", RedisQueue)
], RedisQueue.prototype, "process", null);
exports.RedisQueue = RedisQueue;
//# sourceMappingURL=RedisQueue.js.map